##
## NGINX Reverse Proxy für SealAI
##

# Upgrade-Header sauber setzen (http-Kontext, außerhalb von server{}-Blöcken)
map $http_upgrade $connection_upgrade {
  default upgrade;
  ''      close;
}

# HTTP: ACME + Redirect
server {
  listen 80;
  listen [::]:80;
  server_name sealai.net www.sealai.net auth.sealai.net;

  location ^~ /.well-known/acme-challenge/ {
    root /var/www/certbot;
    default_type "text/plain";
  }

  location = /health { return 200 'ok'; add_header Content-Type text/plain; }

  return 301 https://$host$request_uri;
}

# HTTPS Hauptdomain
server {
  listen 443 ssl;
  listen [::]:443 ssl;
  http2 on;
  server_name sealai.net www.sealai.net;

  ssl_certificate     /etc/letsencrypt/live/sealai.net/fullchain.pem;
  ssl_certificate_key /etc/letsencrypt/live/sealai.net/privkey.pem;

  add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;

  # NextAuth: große Header -> eigene Location
  location ^~ /api/auth/ {
    proxy_http_version 1.1;
    proxy_set_header Host              $host;
    proxy_set_header X-Real-IP         $remote_addr;
    proxy_set_header X-Forwarded-For   $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
    proxy_set_header Upgrade           $http_upgrade;
    proxy_set_header Connection        $connection_upgrade;

    proxy_buffer_size       256k;
    proxy_buffers           16 256k;
    proxy_busy_buffers_size 512k;

    proxy_read_timeout 120s;
    proxy_send_timeout 120s;
    proxy_pass http://frontend:3000;
  }

  # Frontend (Next.js)
  location / {
    proxy_http_version 1.1;
    proxy_set_header Host              $host;
    proxy_set_header X-Real-IP         $remote_addr;
    proxy_set_header X-Forwarded-For   $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
    proxy_set_header Upgrade           $http_upgrade;
    proxy_set_header Connection        $connection_upgrade;
    proxy_read_timeout 120s;
    proxy_send_timeout 120s;
    proxy_pass http://frontend:3000;
  }

  # Backend API (REST)
  location ^~ /api/v1/ {
    proxy_http_version 1.1;
    proxy_set_header Host              $host;
    proxy_set_header X-Real-IP         $remote_addr;
    proxy_set_header X-Forwarded-For   $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
    proxy_read_timeout 120s;
    proxy_send_timeout 120s;
    proxy_pass http://backend:8000/api/v1/;
  }

# WebSocket (neuer Frontend-Pfad) -> map auf Backend /api/v1/ai/ws
location = /api/v1/chat/ws {
  proxy_http_version 1.1;
  proxy_set_header Upgrade           $http_upgrade;
  proxy_set_header Connection        $connection_upgrade;
  proxy_set_header Host              $host;
  proxy_set_header X-Real-IP         $remote_addr;
  proxy_set_header X-Forwarded-For   $proxy_add_x_forwarded_for;
  proxy_set_header X-Forwarded-Proto $scheme;
  proxy_read_timeout 86400s;
  proxy_send_timeout 86400s;
  proxy_buffering off;
  proxy_pass http://backend:8000/api/v1/ai/ws;   # <— WICHTIG: ai/ws!
}

  # WebSocket (bestehender Alias) -> /api/v1/ai/ws
  location = /api/v1/ai/ws {
    proxy_http_version 1.1;
    proxy_set_header Upgrade           $http_upgrade;
    proxy_set_header Connection        $connection_upgrade;
    proxy_set_header Host              $host;
    proxy_set_header X-Real-IP         $remote_addr;
    proxy_set_header X-Forwarded-For   $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
    proxy_read_timeout 86400s;
    proxy_send_timeout 86400s;
    proxy_buffering off;
    proxy_pass http://backend:8000/api/v1/ai/ws;
  }

location = /api/v1/chat/sse {
  proxy_http_version 1.1;
  proxy_set_header Host              $host;
  proxy_set_header X-Real-IP         $remote_addr;
  proxy_set_header X-Forwarded-For   $proxy_add_x_forwarded_for;
  proxy_set_header X-Forwarded-Proto $scheme;
  proxy_read_timeout 86400s;
  proxy_send_timeout 86400s;
  proxy_buffering off;
  proxy_request_buffering off;
  chunked_transfer_encoding on;
  add_header X-Accel-Buffering no;
  add_header Cache-Control "no-cache, no-transform";
  proxy_pass http://backend:8000/api/v1/langgraph/sse;  # <— Pfad an dein Backend anpassen
}

  # SSE (bestehender Pfad) -> /api/v1/langgraph/
  location ^~ /api/v1/langgraph/ {
    proxy_http_version 1.1;
    proxy_set_header Host              $host;
    proxy_set_header X-Real-IP         $remote_addr;
    proxy_set_header X-Forwarded-For   $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
    proxy_read_timeout 86400s;
    proxy_send_timeout 86400s;
    proxy_buffering off;
    proxy_request_buffering off;
    chunked_transfer_encoding on;
    add_header X-Accel-Buffering no;
    add_header Cache-Control "no-cache, no-transform";
    proxy_pass http://backend:8000/api/v1/langgraph/;
  }

  location = /health { proxy_pass http://backend:8000/health; }
}

# HTTPS Auth-Subdomain → Keycloak
server {
  listen 443 ssl;
  listen [::]:443 ssl;
  http2 on;
  server_name auth.sealai.net;

  ssl_certificate     /etc/letsencrypt/live/auth.sealai.net/fullchain.pem;
  ssl_certificate_key /etc/letsencrypt/live/auth.sealai.net/privkey.pem;

  add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;

  location / {
    proxy_http_version 1.1;

    proxy_set_header Host              $host;
    proxy_set_header X-Forwarded-Host  $host;
    proxy_set_header X-Forwarded-Proto https;
    proxy_set_header X-Forwarded-Port  443;
    proxy_set_header X-Real-IP         $remote_addr;
    proxy_set_header X-Forwarded-For   $proxy_add_x_forwarded_for;

    proxy_set_header Upgrade           $http_upgrade;
    proxy_set_header Connection        $connection_upgrade;

    proxy_read_timeout 300s;

    proxy_redirect ~^https?://localhost(/.*)$ https://auth.sealai.net$1;

    proxy_pass http://keycloak:8080;
  }
}
